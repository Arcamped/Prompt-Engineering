/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunknewprogram"] = self["webpackChunknewprogram"] || []).push([["public_combat_js"],{

/***/ "./public/combat.js":
/*!**************************!*\
  !*** ./public/combat.js ***!
  \**************************/
/***/ (() => {

eval("// Define the Unit class, which represents a combat unit in the game.\nclass Unit {\n  constructor(stats, name) {\n    this.stats = stats;\n    this.position = {\n      x: 0,\n      y: 0\n    };\n    this.name = name;\n    this.skills = [];\n  }\n\n  // New method for adding skills to the unit\n  addSkill(skill) {\n    this.skills.push(skill);\n  }\n}\n\n// Define some example skills for the units\nconst fireball = {\n  name: 'Fireball',\n  type: 'ranged',\n  cost: 5,\n  range: 'ranged',\n  rangeValue: 5,\n  action: (attacker, target) => {\n    const damage = rollDice(8);\n    target.stats.HP -= damage;\n    console.log(`${attacker.name} casts Fireball and deals ${damage} damage to ${target.name}. ${target.name}'s HP: ${target.stats.HP}`);\n  }\n};\nconst charge = {\n  name: 'Charge',\n  type: 'melee',\n  cost: 0,\n  range: 'melee',\n  rangeValue: 1,\n  action: (attacker, target) => {\n    const damage = rollDice(6) + attacker.stats.Strength;\n    target.stats.HP -= damage;\n    console.log(`${attacker.name} charges at ${target.name} and deals ${damage} damage. ${target.name}'s HP: ${target.stats.HP}`);\n  }\n};\nconst heal = {\n  name: 'Heal',\n  type: 'melee',\n  cost: 3,\n  range: 'melee',\n  rangeValue: 1,\n  action: (attacker, target) => {\n    const healAmount = rollDice(8) + attacker.stats.Wisdom;\n    target.stats.HP += healAmount;\n    console.log(`${attacker.name} heals ${target.name} for ${healAmount} HP. ${target.name}'s HP: ${target.stats.HP}`);\n  }\n};\n\n// Define the Grid class, which represents the game board where combat takes place\nclass Grid {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    // Create a 2D array of size (height x width) to represent the grid.\n    this.grid = Array.from({\n      length: height\n    }, () => Array(width).fill(null));\n  }\n\n  // Place a unit at the specified position on the grid\n  placeUnit(unit, x, y) {\n    this.grid[y][x] = unit;\n    unit.position = {\n      x,\n      y\n    };\n  }\n\n  // Move a unit to the specified position on the grid\n  moveUnit(unit, x, y) {\n    // Check if the move is valid before actually moving the unit\n    if (this.isValidMove(unit, x, y)) {\n      // Remove the unit from its old position on the grid\n      const {\n        x: oldX,\n        y: oldY\n      } = unit.position;\n      this.grid[oldY][oldX] = null;\n      // Add the unit to its new position on the grid\n      this.placeUnit(unit, x, y);\n    }\n  }\n\n  // Check if a move is valid for a given unit\n  isValidMove(unit, x, y) {\n    // Calculate the distance between the starting position and the target position\n    const {\n      x: startX,\n      y: startY\n    } = unit.position;\n    const distance = Math.abs(startX - x) + Math.abs(startY - y);\n\n    // Check if the distance is within the unit's movement range\n    if (distance > unit.stats.Movement) {\n      return false;\n    }\n\n    // Check if the target position is already occupied by another unit\n    if (this.unitAt(x, y) !== null) {\n      return false;\n    }\n\n    // Check if there are any obstacles (other units) in the path between the starting and target positions\n    const steps = Math.max(Math.abs(x - startX), Math.abs(y - startY));\n    for (let i = 1; i < steps; i++) {\n      const ix = startX + i * stepX;\n      const iy = startY + i * stepY;\n      if (this.grid[iy][ix] !== null) {\n        return false;\n      }\n    }\n    // If none of the above conditions were met, then the move is valid\n    return true;\n  }\n  unitAt(x, y) {\n    return this.grid[y][x];\n  }\n\n  // Add other grid management functions\n}\n\n/*\r\nrender() {\r\n    let table = document.createElement('table');\r\n    table.classList.add('grid');\r\n    \r\n    for (let y = 0; y < this.height; y++) {\r\n        let row = table.insertRow(y);\r\n        for (let x = 0; x < this.width; x++) {\r\n            let cell = row.insertCell(x);\r\n            if (this.grid[y][x] !== null) {\r\n                cell.textContent = this.grid[y][x].name;\r\n            } else {\r\n                cell.textContent = '';\r\n            }\r\n        }\r\n    }\r\n    return table;\r\n}\r\n*/\n\nfunction rollDice(sides) {\n  return Math.floor(Math.random() * sides) + 1;\n}\n// Calculates the initiative order for a list of units by rolling a 20-sided die and adding the unit's dexterity score. Returns an array of the units in initiative order.\nfunction calculateInitiative(units) {\n  const initiatives = units.map(unit => ({\n    unit,\n    initiative: rollDice(20) + unit.stats.Dexterity\n  }));\n  initiatives.sort((a, b) => b.initiative - a.initiative);\n  return initiatives.map(entry => entry.unit);\n}\n// Calculates the damage dealt by a melee attack, subtracts it from the target's HP, and logs the result to the console.\nfunction meleeAttack(attacker, target) {\n  const damage = rollDice(6);\n  target.stats.HP -= damage;\n  console.log(`${attacker.name} deals ${damage} damage to ${target.name}. ${target.name}'s HP: ${target.stats.HP}`);\n}\n// Calculates the damage dealt by a ranged attack, subtracts it from the target's HP, and logs the result to the console.\nfunction rangedAttack(attacker, target) {\n  const damage = rollDice(4);\n  target.stats.HP -= damage;\n  console.log(`${attacker.name} deals ${damage} damage to ${target.name}. ${target.name}'s HP: ${target.stats.HP}`);\n}\n// Returns true if two units are adjacent to each other on the grid, meaning they are within one tile of each other horizontally, vertically, or diagonally.\nfunction isAdjacent(unit1, unit2) {\n  const {\n    x: x1,\n    y: y1\n  } = unit1.position;\n  const {\n    x: x2,\n    y: y2\n  } = unit2.position;\n  return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1;\n}\n// Returns true if two units are adjacent to each other on the grid, meaning they are within one tile of each other horizontally, vertically, or diagonally.\nfunction isWithinRange(unit1, unit2, range) {\n  const {\n    x: x1,\n    y: y1\n  } = unit1.position;\n  const {\n    x: x2,\n    y: y2\n  } = unit2.position;\n  return Math.abs(x1 - x2) <= range && Math.abs(y1 - y2) <= range;\n}\n// Returns a promise that resolves to the user's input in response to a given prompt.\nasync function getInput(prompt) {\n  return new Promise(resolve => {\n    const rl = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'readline'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n      input: process.stdin,\n      output: process.stdout\n    });\n    rl.question(prompt, input => {\n      rl.close();\n      resolve(input);\n    });\n  });\n}\n\n// Implements a turn for a player-controlled unit, prompting the player to choose an action (move, attack, skill, or end) and executing the corresponding code.\nasync function playerTurn(player, enemies, grid) {\n  let turnEnded = false;\n  while (!turnEnded) {\n    const action = await getInput(`${player.name}, choose an action (move, attack, skill, end): `);\n    switch (action.toLowerCase()) {\n      case 'move':\n        const newX = parseInt(await getInput('Enter new X position: '), 10);\n        const newY = parseInt(await getInput('Enter new Y position: '), 10);\n        if (grid.isValidMove(player, newX, newY)) {\n          grid.moveUnit(player, newX, newY);\n          console.log(`${player.name} moved to (${newX}, ${newY})`);\n        } else {\n          console.log('Invalid move. Please try again.');\n        }\n        break;\n      case 'attack':\n        const targetIndex = parseInt(await getInput('Choose target enemy (0-based index): '), 10);\n        const target = enemies[targetIndex];\n        if (!target) {\n          console.log('Invalid target. Please try again.');\n          break;\n        }\n        if (isAdjacent(player, target)) {\n          meleeAttack(player, target);\n        } else if (isWithinRange(player, target, 5)) {\n          rangedAttack(player, target);\n        } else {\n          console.log('Target is out of range. Please try again.');\n        }\n        break;\n      case 'skill':\n        const skillIndex = parseInt(await getInput('Choose a skill (0-based index) or enter \"cancel\" to cancel: '), 10);\n        if (isNaN(skillIndex)) {\n          console.log('Invalid input. Please try again.');\n          continue;\n        }\n        if (skillIndex < 0 || skillIndex >= player.skills.length) {\n          console.log('Invalid skill index. Please try again.');\n          continue;\n        }\n        const skill = player.skills[skillIndex];\n        if (skill.cost > player.stats.MP) {\n          console.log('Not enough MP. Please try again.');\n          continue;\n        }\n        if (skill.range === 'melee') {\n          const targetIndex = parseInt(await getInput('Choose target enemy (0-based index): '), 10);\n          const target = enemies[targetIndex];\n          if (!target) {\n            console.log('Invalid target. Please try again.');\n            continue;\n          }\n          if (isAdjacent(player, target)) {\n            skill.action(player, target);\n          } else {\n            console.log('Target is out of range. Please try again.');\n            continue;\n          }\n        } else if (skill.range === 'ranged') {\n          const targetIndex = parseInt(await getInput('Choose target enemy (0-based index): '), 10);\n          const target = enemies[targetIndex];\n          if (!target) {\n            console.log('Invalid target. Please try again.');\n            continue;\n          }\n          if (isWithinRange(player, target, skill.rangeValue)) {\n            skill.action(player, target);\n          } else {\n            console.log('Target is out of range. Please try again.');\n            continue;\n          }\n        } else if (skill.range === 'aoe') {\n          const targets = enemies.filter(enemy => isWithinRange(player, enemy, skill.rangeValue));\n          skill.action(player, targets);\n        }\n        player.stats.MP -= skill.cost;\n        console.log(`${player.name} used ${skill.name}. ${player.name}'s MP: ${player.stats.MP}`);\n        break;\n      case 'end':\n        turnEnded = true;\n        console.log(`${player.name}'s turn has ended.`);\n        break;\n      default:\n        console.log('Invalid action. Please try again.');\n    }\n  }\n}\n\n// Implements a turn for a ChatGPT-controlled enemy unit, choosing an action based on the current game state and executing the corresponding code.\nfunction chatgptTurn(enemy, allies, grid) {\n  // Implement ChatGPT-controlled enemy's turn\n}\n\n// Runs a combat between two sides (allies and enemies), alternating turns between units and checking for defeat conditions (all allies defeated or all enemies defeated). Returns the name of the winning side.\nasync function combat(allies, enemies, grid) {\n  const allUnits = allies.concat(enemies);\n  while (true) {\n    const initiativeOrder = calculateInitiative(allUnits);\n    for (const unit of initiativeOrder) {\n      if (allies.includes(unit)) {\n        playerTurn(unit, enemies, grid);\n      } else {\n        chatgptTurn(unit, allies, grid);\n      }\n\n      // Check if one side has been defeated\n      const alliesDefeated = allies.every(ally => ally.stats.HP <= 0);\n      const enemiesDefeated = enemies.every(enemy => enemy.stats.HP <= 0);\n      if (alliesDefeated || enemiesDefeated) {\n        return alliesDefeated ? 'Enemies' : 'Allies';\n      }\n    }\n  }\n}\n\n// Initializes the game elements, including the player, allies, enemies, and grid, places the units on the grid, and runs the combat loop. Logs the winner to the console at the end of the game.\nasync function mainCombat() {\n  // Initialize game elements\n  const playerStats = {\n    Strength: 10,\n    Dexterity: 10,\n    Intelligence: 10,\n    Constitution: 10,\n    Wisdom: 10,\n    Movement: 5,\n    HP: 20,\n    MP: 10\n  };\n  const player = new Unit(playerStats, 'Player');\n  const grid = new Grid(10, 10);\n\n  // Initialize enemies and allies\n  const allies = [player];\n  const enemies = [new Unit({\n    ...playerStats,\n    Dexterity: 8\n  }, 'Enemy 1'), new Unit({\n    ...playerStats,\n    Dexterity: 12\n  }, 'Enemy 2')];\n\n  // Add the skills to the unitscd\n  player.addSkill(charge);\n  player.addSkill(heal);\n  enemies[0].addSkill(fireball);\n  enemies[1].addSkill(charge);\n  // Place units on the grid\n  grid.placeUnit(player, 1, 1);\n  grid.placeUnit(enemies[0], 8, 8);\n  grid.placeUnit(enemies[1], 9, 9);\n\n  // Run the combat\n  const winner = combat(allies, enemies, grid);\n  console.log(`The winner is: ${winner}`);\n}\n\n// combat();\n\n//# sourceURL=webpack://newprogram/./public/combat.js?");

/***/ })

}]);